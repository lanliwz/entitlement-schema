Entitlement Schema – Step-by-Step Walkthrough

Continue with the high level instruction, let me show you how the Entitlement Schema works in practice.
We’ll start with the high-level graph structure in Neo4j, then drill down into specific policies, groups, and user entitlements.

Here are the building blocks of the model:
	•	Users are the people or subjects, in this demo, we have 3 users, Alic, Carol and Bob
	•	Policy Groups bundle access rules into personas, here we have Finance, HR, and IT groups.
	•	Policies define the actual rules. Here we have "HR Department Only" rule, this rule "Allow access only to rows where dept_name = 'HR'"
	we also have "Mask Salary" rule, which make sure that salaries are fully masked before being displayed.
	•	We tie those rules directly to columns, which belong to tables and schemas, so every entitlement is anchored to the physical database structure.

Here is the sequence from user's input to get the entitlement enforced result:
    1. user submit a query to one of entitlement enforced database, for this demo, bank database in mysql server
    2. Send the query to SQL parser
    3. The query is parsed and a list of tables/views send back
    4. fetch all entitlements for this user and tables
    5. get all entitlements
    6. send the original query and entitlements to SQL Rewriter agent
    7. get query with proper filter and masking functions
    8. execute the rewritten query

Run the demo to see the entitlement in action:

Carol is a member of the IT Group.

For him:
	•	Only rows where dept_name = IT appear.
	•	The salary column is fully masked to 0.00.

Alice is a member of the Finance Group.

For her:
	•	Only rows where dept_name = Finance appear.
	•	The salary column is fully masked to 0.00.


Bob is a member of the Client Support Group.

For him:
	•	all rows appear.
	•	The salary column is fully masked to 0.00.

Beyond enforcement, governance is critical.
Each policy and relationship carries metadata—definitions, status flags, and effective dates.
This means compliance teams can query:
	•	Who has access to this column?
	•	When was this policy last certified?
	•	What’s the lifecycle status of this rule?

All of this is queryable directly from the graph.

So in summary:
	•	Policies define rules.
	•	Policy Groups organize them into personas.
	•	Users inherit access via group membership.
	•	Every rule is tied to the physical schema, making enforcement, traceability, and audit seamless.

With this design, we achieve granularity, compliance, and operational simplicity—all in one model.
